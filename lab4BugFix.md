1. 参考redis实现，使用push的方式，发送迁移的数据，简单处理的话
就是一下子发送所有迁移的数据，此时如果有客户端访问旧节点迁移的key的话，就直接阻塞住，等待迁移完成再重定向。

或者和redis一样，分批次迁移，此时就需要一个map，保存迁移的key，然后根据情况进行重定向

迁移也是一个command，也需要start，迁移rpc需要等待提交后才返回。

指定一个正在迁移的bool即可

还需要位示图表示拥有的分片

节点自己维护session，session不是共享的，所以迁移的时候也需要一起迁移

只有迁移完全完成，日志提交之后，才会删除要迁移的分片

group之间需要rpc，就要考虑幂等问题

push只能针对于group的leader，所以也得轮询

记录一个configId，即类似于term的逻辑时钟
对于被push的group来说
如果configId比我的小，则忽略
如果大，则重新拉取配置，然后再判断是否相等，如果还大，就报错，如果小，就忽略
如果等于，就接收这个
收到rpc后，判断分片配置，如果迁移完成了（map的value为true），则忽略这个rpc
（解决乱序，重复）

超时重发（解决丢失）

2个标志位:配置刷新完成、就绪标志，和正在迁移的标志（一个map，因为可能从多个节点处迁移）（或者是节点有效标志）
2个map，迁移map和占有的分片的有效map

注意日志提交的时候，不是一整个锁，是锁定，没锁，锁定！所以可能出现中途状态变更

状态机执行迁移命令的时候，会检查标志位。

每次rpc只会迁移一个分片
2. lab4中，因为版本可能变，所以必须等待写的返回值，来决定是否重试，见
https://zhuanlan.zhihu.com/p/51049133
3. 监听迁移完成，客户端会无脑最新的分片，客户端请求的时候需要拉取最新的配置，借助select通道超时，完成超时自动拉取配置。
   保存当前负责的shard
   配置更新也要日志提交，
   使用push的方式，接受到push也要拉取最新的配置，判断版本号，决定是否拒绝，还是接受迁移。删除和增加都要日志提交。
   有一个发送线程，发送迁移的分片，发送时检验曾经发送过的分片版本号，版本号是每次修改添加的，这样防止发送无用的rpc。
   每次配置变更，都会清空发送队列。
   只有主节点在配置变更的时候会生成任务。如果主节点挂了，新的主节点会先拉取最新配置，然后根据差异自动生成任务。
   发送时检验是否是主节点，不是的话拒绝发送
   接收方也要检验发送的分片有没有意义。
4. lab4A要实现负载均衡
controller就是配置中心，只会被拉取，不会推送
配置中心会保存历史配置
5. 需要保证负载均衡算法是可以复现的，即每个节点执行的结果是一样的！
6. 其实自己产生随机数当客户端id就行了。。。但是实际应用中有重复的风险，面试不能说
7. 注意：主节点一定不在崩溃回复状态中
8. 配置变更可以自己拉取实现，也可以leader拉取，然后通过日志提交实现
9. 不论咋样，就3个问题：1分片怎么发送怎么接受，主节点崩溃咋办；2状态机对不负责的执行不执行检验；3如何启动

对于自己拉取而言（缺点是rpc数目很多）：
1.节点自己拉取配置，并自动设置ready map，主节点会记录当前提交的日志id，然后wait for状态机执行完，然后生成发送任务，并清空发送队列
如果主节点崩溃了，新的主节点一定不在崩溃回复中，那么就一样的操作，重发即可，即拉取配置的代码中if state==leader即可
此外，如果主节点发送到一半崩溃了，还需要补充发送，解决办法就是，拉取配置的时候，不论配置是否更新，都会等待状态机执行完这个index（或者直接发送，因为上次配置改变的时候已经提交日志了，从那个时候开始，已经拒绝不符合的请求了，所以直接发送，就是最新的！） ，然后查看发送队列， 
无脑清空发送队列，并且生成新的任务，所以配置拉取频率不要太高
必须在拉取配置额时候，即使配置不变，也要检查是否有需要发送的，如果有，仍然提交日志（或者直接发送，因为上次配置改变的时候已经提交日志了，从那个时候开始，已经拒绝不符合的请求了，所以直接发送，就是最新的！）
接收方对版本号进行检验，如果不符合的话，返回状态码，发送方重新拉取配置
发送的时候的依据是自己有没有对应的shard，所以新的leader也不会多次重发！
2.状态机必须不检验任何负责不负责分片的信息，如果状态机有这个shard存在，就执行，否则不执行，因为配置拉取是先行一步的，会自动阻止不负责的请求
而状态机必须吧上个配置的请求执行完才行。对于receive，直接执行（即使不负责），因为都有receive了，说明另一个group可能已经delete了！；delete，也直接执行。
如果receive的已经有了，应该拒绝执行，事实上，不同group之间也要维护一个seqId，clientId=gid（注意当配置中没有这个group的时候，就要删除session，即在拉取配置的时候，clean一下session map），这样才能保证防止重发
3.找最近的由0个group变成一个的对应index，（一般是1，一般不会全部退出吧。。），判断自己是不是这个group的，如果是，那就设置为全部分片都是ready！
其实就刚开始启动的时候需要，后面即使崩溃回复了，也不需要读取num=1的配置了，因为已经有日志了
follower也没必要拉取，因为修改了也只有leader才能执行。。

对于日志提交而言
1.只有leader才能拉取，拉取成功后提交日志。 并直接更新ready等，拒绝不合理请求
状态机执行日配置改变的日志的时候，会根据自己是否是主节点来生成发送任务，清空发送队列，此时可以保证之前的都执行完了。
主节点正常崩溃的话，新的leader进行拉取，然后日志提交即可
主节点发送到一半崩溃的话，咋办？
必须在拉取配置额时候，即使配置不变，也要检查是否有需要发送的，如果有，仍然提交日志（或者直接发送，因为上次配置改变的时候已经提交日志了，从那个时候开始，已经拒绝不符合的请求了，所以直接发送，就是最新的！）
接收方对版本号进行检验，如果不符合的话，返回状态码，发送方重新拉取配置
发送的时候的依据是自己有没有对应的shard，所以新的leader也不会多次重发！
2.状态机必须不检验任何负责不负责分片的信息，如果状态机有这个shard存在，就执行，否则不执行，因为配置拉取是先行一步的，会自动阻止不负责的请求
而状态机必须吧上个配置的请求执行完才行。对于receive，直接执行（即使不负责），因为都有receive了，说明另一个group可能已经delete了！；delete，也直接执行。
如果receive的已经有了，应该拒绝执行，事实上，不同group之间也要维护一个seqId，clientId=gid（注意当配置中没有这个group的时候，就要删除session，即在拉取配置的时候，clean一下session map），这样才能保证防止重发
3.和上面类似，因为是崩溃回复了就是从节点了，所以只会无脑执行日志而已，只要第一次的时候leader拉取num=1，然后日志提交就行

**上面有说的不对的。。**
最终方案，借助于日志提交：
1.只有leader才能拉取，如果版本号高，那就提交日志，并且等待状态机执行完这个日志。即完成配置转换
状态机执行日配置改变的日志的时候，会根据自己是否是主节点来生成发送任务，清空发送队列，此时可以保证之前的都执行完了。
拉取的时候，如果发现配置不变，那就读取当前是否有不负责的，如果有，那就添加任务
必须在拉取配置额时候，即使配置不变，也要检查是否有需要发送的，如果有，直接发送，因为上次配置改变的时候已经提交日志了，从那个时候开始，已经拒绝不符合的请求了，所以直接发送，就是最新的！
接收方对版本号进行检验，如果不符合的话，返回状态码，发送方重新拉取配置，**校验版本前，先拉取新版本！等待状态机执行完！**
发送的时候的依据是自己有没有对应的shard，所以新的leader也不会多次重发！
2.状态机会检验任何负责不负责分片的信息，并且返回错误，这样就可以让客户端重试写操作
对于receive，直接执行（即使不负责），因为都有receive了，说明另一个group可能已经delete了！；delete，也直接执行。
如果receive的已经有了，应该拒绝执行，事实上，不同group之间也要维护一个seqId，clientId=gid（注意当配置中没有这个group的时候，就要删除session，即在拉取配置的时候，clean一下session map），这样才能保证防止重发
3.和上面类似，因为是崩溃回复了就是从节点了，所以只会无脑执行日志而已，只要第一次的时候leader（是leader，且lastApplied=0）拉取num=1，然后日志提交就行


BUG FIX:
1. 是否要在rpc handler中拉取最新的版本？receive rpc中要拉取，get put append rpc在waitUitlReady拉取，因为否则可能会在错误的版本判断是否ready！
2. 判断是否是leader的if必须在前面！因为不是leader的话，判断是否对这个shard负责也是没意义的！
3. *发送RPC的时候不能加锁！，否则可能导致互相发送，然后就死锁了，因为无法进入rpc handler！*
4. *细粒度的锁，也会导致互斥性比较弱，导致方法内状态改变*，就会引入很多if判断！
5. 并发修改的时候，出现2号分片，101 group先负责，然后不负责，然后又负责的情况，阶段1写了2号分片，阶段2另一个group写了2号分片，然后变成阶段3了应该要接收到分片才行
否则会丢失修改。。
所以导致，发送的时候我认为你负责这个分片，消息到了之后，你发现不负责，就放弃了，我也没删除，后来我又负责了，就直接在原地添加了
6. 如果拉取的版本号不是当前+1的话，（可以强行v+1进行日志提交）就需要判断这期间是否没发生所有权变化，
7. 调用客户端的query方法的时候，也不要锁定
8. 使用类似于路由器的方式，一跳一跳的发送，这样就有确定性了！而不是发送给最新的target！
9. 状态机不要负责转发，但是必须负责true等的转换
10. 其实配置变更的生效时间无所谓，只要保证能生效就行了！
11. 因为日志已经提交了，所以直接修改为最新的，即可保证后续log中的entry一定是我负责的！ 但是follower仍然是通过日志来修改config！
12. 异步调用getLatestConfig，但是出现了因为状态机执行速度有限，而每次都按照最新的config来send2Channel，此时就会导致发送脏数据，解决办法：1.改为同步，2.新增一个machineVersion记录
13. 注意，当发送的目标已经退出group的时候，在最新的Config对象中没有存放shard的下一跳位置，这时必须找shard的 lastV+1 的config，退出group后，服务器不一定会kill！
14. 存在一个问题：重复发送，因为我们是接收到版本号大的会覆盖，如何避免路由转发版本号的时候，本身版本号小，但是路由过去大了，导致抢占了正确的数据
当delete不删除当前负责的时候更可能发生，比如每次send2Channel都会把那个不删除的发送出去，但是它可能版本号小
如果是超时重传就没事，
可以保存一个最大发送版本号，只发送一次，超时重传即可，即可保证只发送一次
**如果解决leader挂了的情况？？**
15. 这个可以建模成路由器互联，有源和目的路由器，要保证接收方只能重复接收最新的数据，即不能被抢占
16. 因为异步执行，所以waitUntil的意义也没那么大，不能保证一定能执行，可能出现delete的情况
所以，要么就状态机中返回err，让客户端重试，要么就wait的条件是存在lastVersion=version的shard，而且还是我想要的shard，但是因为异步，也可能有问题，，，



17. persister.RaftStateSize() 11101, but maxraftstate 1000;因为每次get等都会写入日志，但是因为不是提交，所以没法快照，然后就超了。。
18. //存在一个case：主节点挂了，从节点变成主节点，从节点是OUT，进行重发，但是这个group的节点已经进入了下一个version。。此时就会永远无法进入下个version
    //所以ErrOutdated也需要认为是确认收到，因为他肯定曾经收到了，才version++了
