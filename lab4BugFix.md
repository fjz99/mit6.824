1. 参考redis实现，使用push的方式，发送迁移的数据，简单处理的话
就是一下子发送所有迁移的数据，此时如果有客户端访问旧节点迁移的key的话，就直接阻塞住，等待迁移完成再重定向。

或者和redis一样，分批次迁移，此时就需要一个map，保存迁移的key，然后根据情况进行重定向

迁移也是一个command，也需要start，迁移rpc需要等待提交后才返回。

指定一个正在迁移的bool即可

还需要位示图表示拥有的分片

节点自己维护session，session不是共享的，所以迁移的时候也需要一起迁移

只有迁移完全完成，日志提交之后，才会删除要迁移的分片

group之间需要rpc，就要考虑幂等问题

push只能针对于group的leader，所以也得轮询

记录一个configId，即类似于term的逻辑时钟
对于被push的group来说
如果configId比我的小，则忽略
如果大，则重新拉取配置，然后再判断是否相等，如果还大，就报错，如果小，就忽略
如果等于，就接收这个
收到rpc后，判断分片配置，如果迁移完成了（map的value为true），则忽略这个rpc
（解决乱序，重复）

超时重发（解决丢失）

2个标志位:配置刷新完成、就绪标志，和正在迁移的标志（一个map，因为可能从多个节点处迁移）（或者是节点有效标志）
2个map，迁移map和占有的分片的有效map

注意日志提交的时候，不是一整个锁，是锁定，没锁，锁定！所以可能出现中途状态变更

状态机执行迁移命令的时候，会检查标志位。

每次rpc只会迁移一个分片
2. lab4中，因为版本可能变，所以必须等待写的返回值，来决定是否重试，见
https://zhuanlan.zhihu.com/p/51049133
3. 监听迁移完成，客户端会无脑最新的分片，客户端请求的时候需要拉取最新的配置，借助select通道超时，完成超时自动拉取配置。
   保存当前负责的shard
   配置更新也要日志提交，
   使用push的方式，接受到push也要拉取最新的配置，判断版本号，决定是否拒绝，还是接受迁移。删除和增加都要日志提交。
   有一个发送线程，发送迁移的分片，发送时检验曾经发送过的分片版本号，版本号是每次修改添加的，这样防止发送无用的rpc。
   每次配置变更，都会清空发送队列。
   只有主节点在配置变更的时候会生成任务。如果主节点挂了，新的主节点会先拉取最新配置，然后根据差异自动生成任务。
   发送时检验是否是主节点，不是的话拒绝发送
   接收方也要检验发送的分片有没有意义。
4. lab4A要实现负载均衡
controller就是配置中心，只会被拉取，不会推送
配置中心会保存历史配置
5. 需要保证负载均衡算法是可以复现的，即每个节点执行的结果是一样的！